// Make sure to have these definition on top of your code or else Blynk won't be able to connect.
#include <D:\Projects\PIO\TuringV2\TuringV2\include\Creds\BlynkCred.h>
#include <D:\Projects\PIO\TuringV2\TuringV2\include\Creds\a.h>
#define PROTO // Toggle comment to switch between upload to Turing or Jupiter


#define USE_SPIFFS

#define DEBUG
#define BLYNK_PRINT Serial
bool _disable = false;
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>
#include <ESPmDNS.h>
#include "OneWire.h"
#include "DallasTemperature.h"
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\Time-master\TimeLib.h>
#include <HTTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <DNSServer.h>
#include "esp_task_wdt.h"
#ifdef USE_SPIFFS
#include <SPIFFS.h>
#include <SPI.h>
#include "FS.h"
#endif
#include <D:\Projects\PIO\TuringV2\TuringV2\include\Creds\WifiCred.h>

#include "DHT.h"
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\NewPing\src\NewPing.h>
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\NightMare TCP\nightmaretcp.h>

#pragma region New Board pins

#define SIPO_CLK 4
#define SIPO_LATCH 17
#define SIPO_DATA 16

#define MUX_S0 17
#define MUX_S1 16
#define MUX_S2 18
#define MUX_S3 19
#define MUX_ENABLE 25
#define MUX_INPUT 33

#define US_TRIG 27
#define US_ECHO 14

#define WS2812_PIN 23
#define WS2811_PIN 26

#define ONBOARD_RGB_PIN 2
#define ONBOARD_RGB_SIZE 3

// SIPO outputs
#define LED_0 0
#define LED_1 1
#define LED_2 2
#define MOIST_EN0 3
#define MOIST_EN1 4
#define RELAY_PIN 5

// MUX Selectors
#define MOIST_1 0
#define MOIST_2 1
#define RAIN_PIN 5
#define DHT_PIN 9
#define DS18b20_PIN 10
#define WL_BOTTOM 13
#define WL_MIDDLE 12
#define LDR_PIN 14

#pragma endregion

#pragma region FastLED

#include <FastLED.h>

#pragma region HIVE MQTT
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\pubsubclient-2.8\src\PubSubClient.h>
#include <D:\Projects\PIO\TuringV2\TuringV2\include\Creds\HiveMQCred.h>
void HiveMQ_Callback(char *topic, byte *payload, unsigned int length);

WiFiClientSecure hive_client;
PubSubClient HiveMQ(hive_client);

static const char *root_ca PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
-----END CERTIFICATE-----
)EOF";

void MQTT_Send(String topic, String message)
{
    HiveMQ.publish(topic.c_str(), message.c_str(), true);
}

#pragma endregion

// 2 WS2811 lights
// 1 WS2818b strip

// WS2811 Beacons     @26
// WS2812 LED Strip   @23
// 3xWS2812E onboard  @2

#define BEACONS_SIZE 2
#define WS2811_COLOR_ORDER BGR

// best white is TypicalPixelString next is uncorrected
// WS2818b Strip
#define LED_STRIP_SIZE 300
#define LED_STRIP_COLOR_ORDER GRB

#define LED_MAX_AMPS
#define LED_VOLTAGE
#define TOTALSIZE LED_STRIP_SIZE + BEACONS_SIZE + ONBOARD_RGB_SIZE

#define BEACONS_START_INDEX LED_STRIP_SIZE
#define ONBOARD_START_INDEX LED_STRIP_SIZE + BEACONS_SIZE

uint16_t LED_BaseColor_1 = 0x0; // Contains an RGB value for the strip
uint16_t LED_BaseColor_2 = 0x0; // Contains an RGB value for the stripw
int patternIndex = 0;

CRGB leds[LED_STRIP_SIZE];
CRGB beacons_leds[BEACONS_SIZE];
CRGB onboard_leds[ONBOARD_RGB_SIZE];

enum LED_Animations
{
    Solid,
    Blink,
    BlinkTwoColor,
    BlinkFinite,
    IndividualRandom,
    FadeInOutSolid,
    FadeInOutRandom,
    RandomWithFade,
    Codes,
    DebugCodes,
    OnePixelLoop,
    WiFiStrength,
    WiFiStrengthInverse,
};

struct LED_Controller
{
private:
    unsigned long _lastMillis = 0;
    int _Index1 = 0;
    int _Index2 = 0;
    bool _backwards = false;
    bool _progbar_is_running = false;
    int _start_index = 0;
    int _end_index = TOTALSIZE;
    int _num_of_leds = TOTALSIZE;
    int _interval = 25;
    bool _helperFlag = false;
    int _helperInt = 0;

public:
    byte currenthue = 0;
    LED_Animations current_animation = LED_Animations::IndividualRandom;
    CRGB baseColor = CRGB::GreenYellow;
    CRGB baseColor2 = CRGB::Blue;
    LED_Animations old_animation = LED_Animations::Solid;
    CRGB old_baseColor = CRGB::Red;
    CRGB old_baseColor2 = CRGB::Blue;

    // Set which LEDS are being controlled in the LED array, also inverts [start] and [finish] if [finish] < [start]
    void setBoundries(int start, int finish)
    {
        if (finish < start)
        {
            int middleman = finish;
            finish = start;
            start = middleman;
        }
        if (start < 0)
            start = 0;
        if (finish >= TOTALSIZE)
            finish = TOTALSIZE - 1;

        _start_index = start;
        _end_index = finish;
        _num_of_leds = _end_index - _start_index + 1;
    }

    // Sets the interval for the animations in ms min = 10 ms;
    void setInterval(int newInterval)
    {
        if (newInterval < 10)
        {
            newInterval = 10;
        }
        _interval = newInterval;
    }

    // Sets the new mode.
    void setMode(CRGB led_array[], LED_Animations newAnimation, CRGB color1 = 0x0, CRGB color2 = 0x0, int interval = 25, int _arg0 = 0)
    {
        old_animation = current_animation;
        current_animation = newAnimation;

        old_baseColor = baseColor;
        old_baseColor2 = baseColor2;
        baseColor = color1;
        baseColor2 = color2;
        _lastMillis = 0;
        _helperFlag = false;
        _helperInt = 0;

        setInterval(interval);

        if (newAnimation == Solid)
        {
            baseColor = color1;
        }
        else if (newAnimation == IndividualRandom)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = CRGB(random8(), random8(), random8());
            }
        }
        else if (newAnimation == Blink)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
            }
        }
        else if (newAnimation == BlinkTwoColor)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
            }
        }
        else if (newAnimation == BlinkFinite)
        {
            _helperInt = _arg0;
            Serial.println(_arg0);
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
            }
        }
        else if (newAnimation == FadeInOutSolid)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
            }
        }
        else if (current_animation == RandomWithFade)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = CHSV(random8(), 255, 255);
            }
            _helperInt = 0;
        }
        else if (current_animation == OnePixelLoop)
        {
            _helperInt = 0;
            _helperFlag = true;
            for (size_t i = _start_index + 1; i <= _end_index; i++)
            {
                led_array[i] = baseColor2;
            }
            led_array[_start_index] = baseColor;
        }
    }

    void run(CRGB led_array[])
    {
        if (millis() < _lastMillis + _interval || _progbar_is_running)
            return;
        _lastMillis = millis();

        if (current_animation == Solid)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
            }
        }
        else if (current_animation == IndividualRandom)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = CHSV(random8(), 255, 127);
            }
        }
        else if (current_animation == Blink)
        {
            // for (size_t i = _start_index; i <= _end_index; i++)
            // {
            //   leds[i] = CRGB(baseColor.r * _helperFlag, baseColor.g * _helperFlag, baseColor.b * _helperFlag);
            // }
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                CHSV hsv = RGBtoHSV(baseColor);
                hsv.v = hsv.v * _helperFlag;
                led_array[i] = hsv;
            }
            _helperFlag = !_helperFlag;
        }
        else if (current_animation == BlinkTwoColor)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                leds[i] = CRGB(baseColor.r * _helperFlag + baseColor2.r * !_helperFlag, baseColor.g * _helperFlag + baseColor2.g * !_helperFlag, baseColor.b * _helperFlag + baseColor2.b * !_helperFlag);
            }
            _helperFlag = !_helperFlag;
        }
        else if (current_animation == BlinkFinite)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                CHSV hsv = RGBtoHSV(baseColor);
                hsv.v = hsv.v * _helperFlag;
                led_array[i] = hsv;
            }
            Serial.println(_helperInt);

            _helperFlag = !_helperFlag;
            _helperInt--;
            if (_helperInt == 0)
                goToLastMode(led_array);
        }
        else if (current_animation == FadeInOutSolid)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = baseColor;
                int brigthness = 0;
                if (_backwards)
                    brigthness = _helperInt * 10;
                else
                    brigthness = (25 - _helperInt) * 10;
                if (brigthness > 255)
                    brigthness = 255;
                else if (brigthness < 0)
                    brigthness = 0;

                led_array[i].maximizeBrightness(brigthness);
            }
            _helperInt++;
            if (_helperInt == 26)
            {
                _helperInt = 0;
                _backwards = !_backwards;
            }
        }
        else if (current_animation == FadeInOutRandom)
        {
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                led_array[i] = CHSV(random8(), 255, (25 - _helperInt) * 10);
            }
            if (!_backwards)
                _helperInt++;
            else
                _helperInt--;
            if (_helperInt == 26 || _helperInt == 0)
            {
                _helperInt = 0;
                _backwards = !_backwards;
            }
        }
        else if (current_animation == RandomWithFade)
        {
            if (_helperInt >= 100)
            {
                CRGB b = CHSV(random8(), 255, 255);
                for (size_t i = _start_index; i <= _end_index; i++)
                {
                    led_array[i] = b;
                }
                _helperInt = 0;
            }
            else
            {
                fade_raw(led_array, _num_of_leds, 5);
                _helperInt++;
            }
        }
        else if (current_animation == DebugCodes)
        {
            CRGB code_colors[3] = {CRGB::Black, CRGB::Black, CRGB::Black};
            if (WiFi.isConnected())
            {

                int rssi = WiFi.RSSI();
                if (rssi < -80)
                    code_colors[0] = CRGB::DarkOrange;
                if (rssi < -60)
                    code_colors[0] = CRGB::Gold;
                else
                    code_colors[0] = CRGB::DarkGreen;
            }
            else
                code_colors[0] = CRGB::DarkRed;
            if (Blynk.connected())
                code_colors[1] = CRGB::DarkGreen;
            else
                code_colors[1] = CRGB::DarkRed;
            if (HiveMQ.connected())
                code_colors[2] = CRGB::DarkGreen;
            else
                code_colors[2] = CRGB::DarkRed;

            for (size_t i = 0; i < 3; i++)
            {
                if (i <= _end_index)
                    led_array[i] = code_colors[i].nscale8_video(64);
            }
        }
        else if (current_animation == OnePixelLoop)
        {
            led_array[_start_index + _helperInt] = baseColor2;
            if (_helperFlag)
            {
                _helperInt++;
                if (_start_index + _helperInt > _end_index)
                {
                    _helperFlag = !_helperFlag;
                    _helperInt--;
                }
            }
            else
            {
                _helperInt--;
                if (_start_index + _helperInt < _start_index)
                {
                    _helperFlag = !_helperFlag;
                    _helperInt++;
                }
            }
            led_array[_start_index + _helperInt] = baseColor;
        }
        else if (current_animation == WiFiStrength)
        {
            int rssi = WiFi.RSSI();
            int percent_index = map(rssi, -90, -50, _start_index, _end_index);
            for (size_t i = _start_index; i <= _end_index; i++)
            {
                if (i <= percent_index)
                {
                    led_array[i] = baseColor;
                }
                else
                {
                    led_array[i] = baseColor2;
                }
            }
        }
        else if (current_animation == WiFiStrengthInverse)
        {
            int rssi = WiFi.RSSI();
            int percent_index = map(rssi, -90, -50, _start_index, _end_index);
            for (signed int i = _end_index; i >= _start_index; i--)
            {
                if (i >= _end_index - percent_index)
                {
                    led_array[i] = baseColor;
                }
                else
                {
                    led_array[i] = baseColor2;
                }
            }
        }

        FastLED.show();
    }

    CHSV RGBtoHSV(CRGB rgb)
    {
        CHSV hsv = CHSV(0, 0, 0);
        byte xMin = rgb.r;
        if (rgb.g < xMin)
        {
            xMin = rgb.g;
        }
        if (rgb.b < xMin)
        {
            xMin = rgb.b;
        }
        byte xMax = rgb.r;
        if (rgb.g > xMax)
        {
            xMax = rgb.g;
        }
        if (rgb.b > xMax)
        {
            xMax = rgb.b;
        }
        hsv.v = xMax;
        byte delta = xMax - xMin;
        if (xMax != 0)
        {
            hsv.s = (int)(delta)*255 / xMax;
        }
        else
        {
            hsv.h = 0;
            hsv.s = 0;
            return hsv;
        }
        uint hue = 0;
        if (rgb.r == xMax)
        {
            hue = (rgb.g - rgb.b) * 60 / delta;
        }
        else if (rgb.g == xMax)
        {
            hue = 120 + (rgb.b - rgb.r) * 60 / delta;
        }
        else
        {
            hue = 240 + (rgb.r - rgb.g) * 60 / delta;
        }
        if (hue < 0)
        {
            hue += 360;
        }
        hsv.h = map(hue, 0, 360, 0, 255);
        return hsv;
    }
    void goToLastMode(CRGB led_array[])
    {
        setMode(led_array, old_animation, old_baseColor, old_baseColor2, _interval);
    }

    void progBar(CRGB led_array[], byte percentage, byte numLED, CRGB ValueColor = CRGB::DarkGreen, CRGB BackColor = CRGB::DarkRed, int delayMS = 4000)
    {
        _progbar_is_running = true;
        byte oldBrightness = FastLED.getBrightness();
        FastLED.setBrightness(255);
        FastLED.clear();
        if (percentage > 100)
            percentage = 100;
        if (numLED > _end_index)
            numLED = _end_index;
        for (size_t i = _start_index; i < numLED; i++)
        {
            led_array[i] = BackColor;
        }
        FastLED.show();
        int value = round((double)percentage / 100 * numLED);
        for (size_t i = _start_index; i <= value; i++)
        {
            led_array[i] = ValueColor;
            delay(50);
            FastLED.show();
        }
        delay(delayMS);
        FastLED.clear();
        FastLED.setBrightness(oldBrightness);
        _progbar_is_running = false;
    }

    void setCode(CRGB led_array[], String codeString)
    {
        if (current_animation != Codes)
            return;

        CRGB code_colors[3] = {CRGB::Black, CRGB::Black, CRGB::Black};
        if (codeString.length() >= 3)
        {
            for (size_t i = 0; i < 3; i++)
            {
                code_colors[i] = getColorbyChar(codeString[i]);
            }
        }
        else
        {
            for (size_t i = 0; i < codeString.length(); i++)
            {
                code_colors[i] = getColorbyChar(codeString[i]);
            }
        }
        for (size_t i = 0; i < 3; i++)
        {
            led_array[i] = code_colors[i];
        }

        FastLED.show();
    }
    CRGB getColorbyChar(char char_to_parse)
    {
        switch (char_to_parse)
        {
        case 'R':
            return CRGB::Red;
            break;
        case 'G':
            return CRGB::Green;
            break;
        case 'B':
            return CRGB::Blue;
            break;
        case 'Y':
            return CRGB::Yellow;
            break;
        case 'W':
            return CRGB::White;
            break;

        default:
            return CRGB::Black;
            break;
        }
    }
};
LED_Controller LED_Strip, beacons, onBoardLEDs;

// PatternMode oldMode = PatternMode::blink;
void setBeaconColor(CRGB COLOR, bool skipShow = false)
{
    for (size_t i = 0; i < BEACONS_SIZE; i++)
    {
        beacons_leds[i] = COLOR;
    }
    if (!skipShow)
        FastLED.show();
}

void SetOnboardLEDS(CRGB COLOR, bool skipShow = false)
{
    for (size_t i = 0; i < ONBOARD_RGB_SIZE; i++)
    {
        onboard_leds[i] = COLOR;
    }

    if (!skipShow)
        FastLED.show();
}

#pragma endregion




// TEST BUTTON
#define TEST_BUTTON 0
bool digital_debounce = false;


#pragma region TCP server

NightMareTCPServer tcpServer(100);

#pragma endregion

// Callback for payload at the mqtt topic
void HiveMQ_Callback(char *topic, byte *payload, unsigned int length)
{

    // GPT:: String incommingMessage((char*) payload, length);
    String incommingMessage = "";
    for (int i = 0; i < length; i++)
        incommingMessage += (char)payload[i];

    Serial.printf("MQTT::[%s]-->[%s]\n", topic, incommingMessage.c_str());
    String in_topic = "";
    in_topic += topic;
}

void setup()
{
    #define DEVICE_NAME "test"
    // Debug console
    Serial.begin(115200);

    // Declare PinModes

    WiFi.begin(WIFISSID, WIFIPASSWD);
    bool createAp = false; // flag for creating an AP in case we can't connect to wifi
    bool beauty = true;    // Esthetics for Serial.print();
    WiFi.hostname(DEVICE_NAME);
    // Try to connect to WiFi
    int StartMillis = millis();
    while (WiFi.status() != WL_CONNECTED && !createAp)
    {
        if (millis() % 100 == 0 && beauty)
        {
            Serial.print(".");
            beauty = false;
            FastLED.show();
        }
        else if (millis() % 100 != 0)
        {
            beauty = true;
        }

        if (millis() - StartMillis > 14999)
        {
            Serial.printf("\nNetwork '%s' not found.\n", WIFISSID);
            createAp = true;
        }
    }
    if (createAp)
    {
        WiFi.enableAP(true);
        WiFi.mode(WIFI_AP_STA);
        WiFi.softAP(WIFI_SOFTAP_SSID, WIFI_SOFTAP_PASSWD);
        // dnsServer.start(53, "*", WiFi.softAPIP());
        Serial.println("");
        Serial.print("Creating WiFi Ap.\n ---SSID:  ");
        Serial.println(WIFI_SOFTAP_SSID);
        Serial.print(" --IP address: ");
        Serial.println(WiFi.softAPIP());
    }
    else
    {
        // fill_solid(leds, 2, 0x00FF00);

        for (size_t i = 0; i < 5; i++)
        {
            FastLED.setBrightness(255);
            FastLED.show();
            delay(200);
            FastLED.setBrightness(0);
            FastLED.show();
            delay(200);
        }
        Serial.print("Connected to ");
        Serial.println(WIFISSID);
        Serial.print("IP address: ");
        Serial.println(WiFi.localIP());
        Serial.print("Signal RSSI: ");
        Serial.println(WiFi.RSSI());
        Serial.print("DNS IP: ");
        Serial.println(WiFi.dnsIP().toString());
        WiFi.setAutoReconnect(true);
    }
   
    hive_client.setCACert(root_ca);
    HiveMQ.setServer(MQTT_URL, MQTT_PORT);
    HiveMQ.setCallback(HiveMQ_Callback);

    if (HiveMQ.connect(DEVICE_NAME, MQTT_USER_TEST, MQTT_PASSWD_TEST))
        Serial.println("MQTT Connected");
    else
        Serial.printf("Can't Connect to MQTT Error Code : %d\n", HiveMQ.state());
    HiveMQ.subscribe("#");
}

void loop()
{

    HiveMQ.loop();

    EVERY_N_SECONDS(300)
    {

        if (!WiFi.isConnected())
        {
            WiFi.begin(WIFISSID, WIFIPASSWD);
            int StartMillis = millis();
            bool beauty = false;
            Serial.printf("Trying to reconnect to \'%s\'\n", WIFISSID);
            bool beauty_two = false;
            while (WiFi.status() != WL_CONNECTED && millis() - StartMillis < 10000)
            {
                if (millis() % 500 == 0 && beauty)
                {
                    Serial.print(".");
                    beauty = false;
                    onboard_leds[0] = CRGB(0xFF * beauty_two, 0xFF * !beauty_two, 0);
                    beauty_two = !beauty_two;
                    FastLED.show();
                }
                else if (millis() % 100 != 0)
                {
                    beauty = true;
                }
            }
            if (WiFi.status() != WL_CONNECTED)
            {
                Serial.printf("\nNetwork '%s' not found.\n", WIFISSID);
            }
        }
        if (!HiveMQ.connected())
        {
            HiveMQ.disconnect();
            if (HiveMQ.connect(DEVICE_NAME, MQTT_USER, MQTT_PASSWD))
            {
                Serial.println("MQTT Connected");
                HiveMQ.subscribe("#");
            }
            else
                Serial.printf("Can't Connect to MQTT Error Code : %d\n", HiveMQ.state());
        }
    }

#ifdef PROTO
    // TEST AREA
    if (digitalRead(TEST_BUTTON) == LOW && digital_debounce)
    {
        _disable = !_disable;
        FastLED.setBrightness(127 * _disable);
        delay(1);
    }

    if (digitalRead(TEST_BUTTON) == HIGH)
    {
        digital_debounce = true;
    }

    if (Serial.available())
    {
        String s = "";
        while (Serial.available() > 0)
        {
            char c = Serial.read();
            if (c != 10 && c != 13)
            {
                s += c;
            }
        }
    }
#endif
}
