
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>
#include <ESPmDNS.h>
#include "OneWire.h"
#include "DallasTemperature.h"
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\Time-master\TimeLib.h>
#include <HTTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <DNSServer.h>
#include "esp_task_wdt.h"
#ifdef USE_SPIFFS
#include <SPIFFS.h>
#include <SPI.h>
#include "FS.h"
#endif
#include <D:\Projects\PIO\TuringV2\TuringV2\include\Creds\WifiCred.h>

#include "DHT.h"
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\NewPing\src\NewPing.h>
#include <D:\Projects\PIO\TuringV2\TuringV2\lib\NightMare TCP\nightmaretcp.h>

#pragma region New Board pins

#define SIPO_CLK 4
#define SIPO_LATCH 17
#define SIPO_DATA 16

#define MUX_S0 16
#define MUX_S1 17
#define MUX_S2 18
#define MUX_S3 19
#define MUX_ENABLE 25
#define MUX_INPUT 33

#define US_TRIG 27
#define US_ECHO 14

#define WS2812_PIN 23
#define WS2811_PIN 26

#define ONBOARD_RGB 2
#define ONBOARD_RGB_SIZE 3

// SIPO outputs
#define LED_0 0
#define LED_1 1
#define LED_2 2
#define MOIST_EN0 3
#define MOIST_EN1 4
#define RELAY_PIN 5

// MUX Selectors
#define MOIST_1 0
#define MOIST_2 1
#define RAIN_PIN 5
#define DHT_PIN 9
#define DS18b20_PIN 10
#define WL_BOTTOM 13
#define WL_MIDDLE 12
#define LDR_PIN 14

#pragma endregion

#pragma region FastLED

#include <FastLED.h>

// 2 WS2811 lights
// 1 WS2818b strip

// WS2811 Beacons     @26
// WS2812 LED Strip   @23
// 3xWS2812E onboard  @2

#define BEACONS_SIZE 2
#define WS2811_COLOR_ORDER BGR

// best white is TypicalPixelString next is uncorrected
// WS2818b Strip
#define LED_STRIP_SIZE 300
#define LED_STRIP_COLOR_ORDER GRB

#define LED_MAX_AMPS
#define LED_VOLTAGE
#define TOTALSIZE LED_STRIP_SIZE + BEACONS_SIZE + ONBOARD_RGB_SIZE

#define BEACONS_START_INDEX LED_STRIP_SIZE
#define ONBOARD_START_INDEX LED_STRIP_SIZE + BEACONS_SIZE

uint16_t LED_BaseColor_1 = 0x0; // Contains an RGB value for the strip
uint16_t LED_BaseColor_2 = 0x0; // Contains an RGB value for the stripw
int patternIndex = 0;

CRGB leds[TOTALSIZE];

enum PatternMode
{
  blink,
  blinktwo,
  rainbow,
  movingrainbow,
  scaleup,
  scaledown,
  solidColor,
  pumping,
  randomMode,
  sinWaves,
  fillColors,
  randomFill
};

struct Pattern
{

  unsigned long lastMillis = 0;
  int interval = 25;
  int Index1 = 0;
  int Index2 = 0;
  int maxIndex = 20;
  int start_index = 0;
  int end_index = 0;
  byte currenthue = 0;
  CRGB baseColor = CRGB::Red;
  CRGB baseColor2 = CRGB::Blue;
  CRGB baseColor3 = CRGB::Green;
  PatternMode mode = PatternMode::scaleup;
  PatternMode oldMode = PatternMode::scaleup;
  bool backwards = false;
  bool progbar_is_running = false;

  void setMode(PatternMode newMode, CRGB color1 = 0x0, CRGB color2 = 0x0)
  {
    oldMode = mode;
    mode = newMode;
    lastMillis = 0;

    if (mode == PatternMode::pumping)
    {
      Index1 = Index1 / 2;
      interval = 25;
      backwards = false;
    }
    else if (mode == PatternMode::scaleup)
    {
      Index1 = 0;
      interval = 25;
      backwards = false;
    }
    else if (mode == PatternMode::randomMode)
    {
      Index1 = 0;
      interval = 25;
      backwards = false;
    }
    else if (mode == PatternMode::sinWaves)
    {
      interval = 15;
      Index1 = 0;
    }
    else if (mode == PatternMode::fillColors)
    {
      interval = 25;
      Index1 = 0;
    }
    else if (mode == PatternMode::solidColor)
    {
      baseColor = color1;
      interval = 500;
    }
    else if (mode == PatternMode::randomFill)
    {
      interval = 15;
      Index1 = 0;
      backwards = false;
    }
  }

  void run()
  {
    if (millis() < lastMillis + interval || progbar_is_running)
      return;
    lastMillis = millis();
    // interval = map(Index1,maxIndex,0,15,75);

    if (mode == PatternMode::scaleup)
    {
      int index = Index1;
      if (backwards)
        index = end_index - 1 - Index1;
      int pos = 0;
      pos = map(beat8(120, 0), 0, 255, 0, maxIndex - 1); //,59,0,0);
                                                         // if (backwards)
                                                         ///  pos = map(beat8(40,0),255,0,0,maxIndex-1);
      leds[index] = CHSV(map(Index1, 0, maxIndex, currenthue, currenthue + maxIndex), 255, 127);
      Index1++;
      fade_raw(leds, maxIndex, 16);

      if (Index1 >= maxIndex)
      {
        Index1 = 0;
        backwards = !backwards;
        currenthue += 19;
      }
    }
    else if (mode == PatternMode::pumping)
    {
      int index = 30 + Index1;
      int index2 = 29 - Index1;
      if (backwards)
      {
        index = maxIndex - 1 - Index1;
        index2 = 0 + Index1;
      }
      byte b = map(Index1, 0, maxIndex / 2, 128, 170);
      byte c = map(Index1, 0, maxIndex / 2, 170, 128);
      leds[index] = CHSV(b, 255, 127);
      leds[index2] = CHSV(b, 255, 127);
      Index1++;
      fade_raw(leds, maxIndex, 16);
      if (Index1 >= maxIndex / 2)
      {
        Index1 = 0;
        backwards = !backwards;
      }
    }
    else if (mode == PatternMode::randomMode)
    {
      int index = random8(0, maxIndex - 1);
      if (backwards)
        index = maxIndex - 1 - Index1;
      int pos = 0;
      pos = map(beat8(120, 0), 0, 255, 0, maxIndex - 1); //,59,0,0);
                                                         // if (backwards)
                                                         ///  pos = map(beat8(40,0),255,0,0,maxIndex-1);
      leds[index] = CHSV(map(Index1, 0, maxIndex, currenthue, currenthue + maxIndex), 255, 127);
      Index1++;
      fade_raw(leds, maxIndex, 16);

      if (Index1 >= maxIndex)
      {
        Index1 = 0;
        // backwards = !backwards;
        currenthue = random8();
      }
    }
    else if (mode == PatternMode::blink)
    {
      CRGB b[LED_STRIP_SIZE];
      for (size_t i = 0; i < maxIndex; i++)
      {
        if (i >= maxIndex - 1)
          b[0] = leds[i];
        else
          b[i + 1] = leds[i];
      }
      for (size_t i = 0; i < LED_STRIP_SIZE; i++)
      {
        leds[i] = b[i];
      }
    }
    else if (mode == PatternMode::sinWaves)
    {
      int pos = beatsin8(15, 0, maxIndex - 1);
      int pos2 = beatsin8(15, 0, maxIndex - 1, 0, 127);
      int pos3 = beatsin8(10, 0, maxIndex - 1) + beatsin8(20, 0, maxIndex - 1, 0, 75);
      leds[pos2] = CHSV(currenthue, 255, 127);
      leds[pos] = CHSV(currenthue + 85, 255, 127);
      leds[pos3 / 2] = CHSV(currenthue + 169, 255, 127);
      blur1d(leds, maxIndex, 16);
      // blur1d(leds, maxIndex, 16);
      fade_raw(leds, maxIndex, 16);
      if (pos >= maxIndex - 1)
      {
        currenthue = random8();
      }
    }
    else if (mode == PatternMode::fillColors)
    {
      int index = Index1;
      if (backwards)
        index = maxIndex - 1 - Index1;
      leds[index] = CHSV(currenthue, 255, 127);
      // blur1d(leds, maxIndex, 16);
      //  fade_raw(,maxIndex,16);
      FastLED.setBrightness(beatsin8(10, 50, 170, 0, 127));
      Index1++;
      if (Index1 >= maxIndex)
      {
        Index1 = 0;
        backwards = !backwards;
        currenthue = random8();
      }
    }
    else if (mode == PatternMode::solidColor)
    {
      for (size_t i = 0; i < maxIndex; i++)
      {
        leds[i] = baseColor;
      }
    }
    else if (mode == PatternMode::randomFill)
    {
      leds[Index1] = CHSV(currenthue, 255, 127);
      if (backwards)
        Index1--;
      else
        Index1++;
      if ((Index1 >= maxIndex - 1 && !backwards) || (Index1 <= 0 && backwards))
      {
        backwards = !backwards;
        uint8_t newhue = currenthue + 65;
        // while(currenthue - newhue < 10)
        // {
        //   newhue = random8();
        // }
        currenthue = newhue;
      }
    }
    FastLED.show();
  }

  void progBar(byte percentage, byte numLED, CRGB ValueColor = CRGB::DarkGreen, CRGB BackColor = CRGB::DarkRed, int delayMS = 4000)
  {
    progbar_is_running = true;
    byte oldBrightness = FastLED.getBrightness();
    FastLED.setBrightness(255);
    FastLED.clear();
    if (percentage > 100)
      percentage = 100;
    if (numLED > maxIndex)
      numLED = maxIndex;
    for (size_t i = 0; i < numLED; i++)
    {
      leds[i] = BackColor;
    }
    FastLED.show();
    int value = round((double)percentage / 100 * numLED);
    for (size_t i = 0; i <= value; i++)
    {
      leds[i] = ValueColor;
      delay(50);
      FastLED.show();
    }
    delay(delayMS);
    FastLED.clear();
    FastLED.setBrightness(oldBrightness);
    progbar_is_running = false;
  }
};

enum LED_Animations
{
  Solid,
  Blink,
  BlinkTwoColor,
  BlinkFinite,
  IndividualRandom,
  FadeInOutSolid,
  FadeInOutRandom,
};

struct LED_Controller
{
private:
  unsigned long _lastMillis = 0;
  int _Index1 = 0;
  int _Index2 = 0;
  bool _backwards = false;
  bool _progbar_is_running = false;
  int _start_index = 0;
  int _end_index = TOTALSIZE;
  int _interval = 25;
  bool _helperFlag = false;
  int _helperInt = 0;

public:
  byte currenthue = 0;
  LED_Animations current_animation = LED_Animations::IndividualRandom;
  CRGB baseColor = CRGB::GreenYellow;
  CRGB baseColor2 = CRGB::Blue;
  LED_Animations old_animation = LED_Animations::Solid;
  CRGB old_baseColor = CRGB::Red;
  CRGB old_baseColor2 = CRGB::Blue;

  // Set which LEDS are being controlled in the LED array, also inverts [start] and [finish] if [finish] < [start]
  void setBoundries(int start, int finish)
  {
    if (finish < start)
    {
      int middleman = finish;
      finish = start;
      start = middleman;
    }
    if (start < 0)
      start = 0;
    if (finish >= TOTALSIZE)
      finish = TOTALSIZE - 1;

    _start_index = start;
    _end_index = finish;
  }

  // Sets the interval for the animations in ms min = 10 ms;
  void setInterval(int newInterval)
  {
    if (newInterval < 10)
    {
      newInterval = 10;
    }
    _interval = newInterval;
  }

  // Sets the new mode.
  void setMode(LED_Animations newAnimation, CRGB color1 = 0x0, CRGB color2 = 0x0, int interval = 25, int _arg0 = 0)
  {
    old_animation = current_animation;
    current_animation = newAnimation;

    old_baseColor = baseColor;
    old_baseColor2 = baseColor2;
    baseColor = color1;
    baseColor2 = color2;
    _lastMillis = 0;
    _helperFlag = false;
    _helperInt = 0;

    setInterval(interval);

    if (newAnimation == Solid)
    {
      baseColor = color1;
    }
    else if (newAnimation == IndividualRandom)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = CRGB(random8(), random8(), random8());
      }
    }
    else if (newAnimation == Blink)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
      }
    }
    else if (newAnimation == BlinkTwoColor)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
      }
    }
    else if (newAnimation == BlinkFinite)
    {
      _helperInt = _arg0;
      Serial.println(_arg0);
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
      }
    }
    else if (newAnimation == FadeInOutSolid)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
      }
    }
  }

  void run()
  {
    if (millis() < _lastMillis + _interval || _progbar_is_running)
      return;
    _lastMillis = millis();

    if (current_animation == Solid)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
      }
    }
    else if (current_animation == IndividualRandom)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = CHSV(random8(), 255, 127);
      }
    }
    else if (current_animation == Blink)
    {
      // for (size_t i = _start_index; i <= _end_index; i++)
      // {
      //   leds[i] = CRGB(baseColor.r * _helperFlag, baseColor.g * _helperFlag, baseColor.b * _helperFlag);
      // }
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        CHSV hsv = RGBtoHSV(baseColor);
        hsv.v = hsv.v * _helperFlag;
        leds[i] = hsv;
      }
      _helperFlag = !_helperFlag;
    }
    else if (current_animation == BlinkTwoColor)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = CRGB(baseColor.r * _helperFlag + baseColor2.r * !_helperFlag, baseColor.g * _helperFlag + baseColor2.g * !_helperFlag, baseColor.b * _helperFlag + baseColor2.b * !_helperFlag);
      }
      _helperFlag = !_helperFlag;
    }
    else if (current_animation == BlinkFinite)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        CHSV hsv = RGBtoHSV(baseColor);
        hsv.v = hsv.v * _helperFlag;
        leds[i] = hsv;
      }
      Serial.println(_helperInt);

      _helperFlag = !_helperFlag;
      _helperInt--;
      if (_helperInt == 0)
        goToLastMode();
    }
    else if (current_animation == FadeInOutSolid)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = baseColor;
        int brigthness = 0;
        if (_backwards)
          brigthness = _helperInt * 10;
        else
          brigthness = (25 - _helperInt) * 10;
        if (brigthness > 255)
          brigthness = 255;
        else if (brigthness < 0)
          brigthness = 0;

        leds[i].maximizeBrightness(brigthness);
      }
      _helperInt++;
      if (_helperInt == 26)
      {
        _helperInt = 0;
        _backwards = !_backwards;
      }
    }
    else if (current_animation == FadeInOutRandom)
    {
      for (size_t i = _start_index; i <= _end_index; i++)
      {
        leds[i] = CHSV(random8(), 255, (25 - _helperInt) * 10);
      }
      if (!_backwards)
        _helperInt++;
      else
        _helperInt--;
      if (_helperInt == 26 || _helperInt == 0)
      {
        _helperInt = 0;
        _backwards = !_backwards;
      }
    }

    FastLED.show();
  }

  CHSV RGBtoHSV(CRGB rgb)
  {
    CHSV hsv = CHSV(0, 0, 0);
    byte xMin = rgb.r;
    if (rgb.g < xMin)
    {
      xMin = rgb.g;
    }
    if (rgb.b < xMin)
    {
      xMin = rgb.b;
    }
    byte xMax = rgb.r;
    if (rgb.g > xMax)
    {
      xMax = rgb.g;
    }
    if (rgb.b > xMax)
    {
      xMax = rgb.b;
    }
    hsv.v = xMax;
    byte delta = xMax - xMin;
    if (xMax != 0)
    {
      hsv.s = (int)(delta)*255 / xMax;
    }
    else
    {
      hsv.h = 0;
      hsv.s = 0;
      return hsv;
    }
    uint hue = 0;
    if (rgb.r == xMax)
    {
      hue = (rgb.g - rgb.b) * 60 / delta;
    }
    else if (rgb.g == xMax)
    {
      hue = 120 + (rgb.b - rgb.r) * 60 / delta;
    }
    else
    {
      hue = 240 + (rgb.r - rgb.g) * 60 / delta;
    }
    if (hue < 0)
    {
      hue += 360;
    }
    hsv.h = map(hue, 0, 360, 0, 255);
    return hsv;
  }
  void goToLastMode()
  {
    setMode(old_animation, old_baseColor, old_baseColor2, _interval);
  }

  void progBar(byte percentage, byte numLED, CRGB ValueColor = CRGB::DarkGreen, CRGB BackColor = CRGB::DarkRed, int delayMS = 4000)
  {
    _progbar_is_running = true;
    byte oldBrightness = FastLED.getBrightness();
    FastLED.setBrightness(255);
    FastLED.clear();
    if (percentage > 100)
      percentage = 100;
    if (numLED > _end_index)
      numLED = _end_index;
    for (size_t i = _start_index; i < numLED; i++)
    {
      leds[i] = BackColor;
    }
    FastLED.show();
    int value = round((double)percentage / 100 * numLED);
    for (size_t i = _start_index; i <= value; i++)
    {
      leds[i] = ValueColor;
      delay(50);
      FastLED.show();
    }
    delay(delayMS);
    FastLED.clear();
    FastLED.setBrightness(oldBrightness);
    _progbar_is_running = false;
  }
};
LED_Controller LED_Strip, beacons, onBoardLEDs;
Pattern p;
// PatternMode oldMode = PatternMode::blink;
void setBeaconColor(CRGB COLOR, bool skipShow = false)
{
  for (size_t i = 0; i < BEACONS_SIZE; i++)
  {
    leds[BEACONS_START_INDEX + i] = COLOR;
  }
  if (!skipShow)
    FastLED.show();
}

void SetOnboardLEDS(CRGB COLOR, bool skipShow = false)
{
  for (size_t i = 0; i < ONBOARD_RGB_SIZE; i++)
  {
    leds[ONBOARD_START_INDEX + i] = COLOR;
  }

  if (!skipShow)
    FastLED.show();
}

#pragma endregion


// #define DHT_PIN 17
#define DHT_TYPE DHT11

 // #define RAIN_SENSOR 33
// #define MOISTURE_SENSOR 33
// #define LDR_PIN 32
// #define PUMP_RELAY 25
// #define EMPTY_WATER_LEVEL 18
// #define HALF_WATER_LEVEL 19
// #define DS18_BUS 16
// #define DS18_READS 10


#ifdef PROTO
// TEST BUTTON
#define TEST_BUTTON 0
bool digital_debounce = false;
#endif

#define MAX_HISTORY_SIZE 100

OneWire oneWire(MUX_INPUT);        // Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
DallasTemperature DS18(&oneWire); // Pass our oneWire reference to Dallas Temperature.

DHT dht(MUX_INPUT, DHT_TYPE);

#pragma region TCP server

NightMareTCPServer tcpServer(100);

#pragma endregion

struct Internals
{
  uint sync_light = 0;               // No Idea what does this do
  bool auto_ldr_overriden = false;   // Flag to check if the Auto LDr has been overriden and therefore should be paused and resumed
  uint8_t aut_ldr_resume_time = 0;   // Time to resume the Auto dimming based on the LDR
  bool turn_off_lights_flag = false; // Flag to turn off the lights automaticaly
  // Old Variables
  bool SendWifiResults = false; // Flag to send the results from the wifi scan once its done;
  bool oldWifiStatus = false;   // Flag to not keep wirting to the digital pin ????
  bool is_time_synced = false;  // True if time was synced false if not.
  uint last_sensor_update = 0;  // unix timestamp in seconds of last sensor update.
  uint last_sensor_log = 0;
  uint last_MQTT_update = 0;                             // unix timestamp in seconds of last sensor log.
  bool is_SD_mounted = false, is_SPIFFS_mounted = false; // Flags to see if mount of SD and  SPIFFS were sucessful
  bool time_synced = false;
};

Internals control_variables;

struct Pump_Controller
{
  uint start_time = 0;                 // Millis() of when did the pump started
  bool is_running = false;             // is the pump currently running
  bool programmed_end = false;         // Wheater or not the pump is supposed to stop based on the timer
  uint end_time = 0;                   // Millis() of when the pump is supposed to end
  String last_run_string = "Never On"; // String for the Blynk V10
  uint last_auto_run = 0;              // Time stamp of last time that we auto ran the pump
  bool force_start = false;            // forces the pump to run despites the Water Level sensors
  bool tank_0_percent = false;         // Prevents loops of low water warnings
  bool tank_50_percent = false;        // Prevents loops of half water warnings

#define PUMP_HALF_TO_0_TIME 147707
  byte WaterState = 0;          // The State of the water sensors. overusage of memory this is equal to wl_empty + wl_half
  uint run_time_from_50 = 0;    // Amount of time the pump was on from 50% to 0%
  uint run_time_from_start = 0; // Amount of time the pump was on since manual reset
};
Pump_Controller Pump;

int trigPin = 26;
int echoPin = 27;
int lastState = 0;

NewPing sonar(trigPin, echoPin); // NewPing setup of pins and maximum distance.
byte SIPO_VALUE = 0;
byte MUX_CONTROL[4] = {MUX_S0, MUX_S1, MUX_S2, MUX_S3};
byte MUX_VALUE = 0;
/**
 * Turns on the mux and selects a port to be used.
 * @param port the output pin to be changed. [0-15]
 */
void setMuxPort(byte port)
{
  if (port > 15)
  {
    Serial.printf("No port:%d on mux, max is 15.\n");
    return;
  }
  // Sets the mux selector to the port
  for (int i = 0; i < 4; i++)
  {
    digitalWrite(MUX_CONTROL[i], (port >> i) & 0x01);
  }
  MUX_VALUE = port;
  // Enables the mux
  digitalWrite(MUX_ENABLE, HIGH);
}
/**
 * Writes a bit to the SIPO Shifter. turns off the MUX.
 * @param pin the output pin to be changed. [0-7]
 * @param value the value to be shifted into that pin.
 * @param skipmux skips the mux selection after setting the SIPO
 */
void SIPO_Write(byte pin, bool value, bool skipmux = false)
{
  if (pin > 7)
  {
    Serial.printf("No pin:%d on the SIPO shifter, max is 8.\n");
    return;
  }
  // Disables MUX since SIPO shares DATA and LATCH with MUX Selector pins
  digitalWrite(MUX_ENABLE, LOW);
  SIPO_VALUE = (SIPO_VALUE & ~(1 << pin)) | (value << pin);
  // Serial.print("0b");
  // Serial.println(SIPO_VALUE, BIN);
  digitalWrite(SIPO_LATCH, LOW);
  shiftOut(SIPO_DATA, SIPO_CLK, MSBFIRST, SIPO_VALUE);
  digitalWrite(SIPO_LATCH, HIGH);
  Serial.println("sipo val: ");
  Serial.println(SIPO_VALUE);
  // restore MUX
  if (!skipmux)
  {
    digitalWrite(MUX_ENABLE, HIGH);
    digitalWrite(MUX_S0, MUX_CONTROL[0]);
    digitalWrite(MUX_S1, MUX_CONTROL[1]);
    digitalWrite(MUX_S2, MUX_CONTROL[2]);
    digitalWrite(MUX_S3, MUX_CONTROL[3]);
  }
}
/**
 * Writes a byte to the SIPO Shifter. turns off the MUX.
 * @param newValue The byte to be shifted in.
 */
void SIPO_WriteBYTE(byte newValue)
{
  // Disables MUX since SIPO shares DATA and LATCH with MUX Selector pins
 // digitalWrite(MUX_ENABLE, !LOW);
  digitalWrite(SIPO_LATCH, LOW);
  shiftOut(SIPO_DATA, SIPO_CLK, MSBFIRST, newValue);
  digitalWrite(SIPO_LATCH, HIGH);
  // // restore MUX
  // digitalWrite(MUX_ENABLE, !HIGH);
  // digitalWrite(MUX_S0, MUX_CONTROL[0]);
  // digitalWrite(MUX_S1, MUX_CONTROL[1]);
  // digitalWrite(MUX_S2, MUX_CONTROL[2]);
  // digitalWrite(MUX_S3, MUX_CONTROL[3]);
  SIPO_VALUE = newValue;
}

void setup()
{
  // Debug console
  Serial.begin(115200);
  pinMode(SIPO_LATCH,OUTPUT);
  pinMode(SIPO_CLK,OUTPUT);
  pinMode(SIPO_DATA,OUTPUT);
}

void loop()
{
 for (size_t i = 0; i < 0xFF; i++)
 {
  SIPO_WriteBYTE(i);
  Serial.println(i);
  delay(500);
 }
 
}
